!function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=17)}([function(e,t){e.exports=React},function(e,t,n){const{mainTerm:a}=n(5),{createTokensTerm:r}=n(6),{purchaseTokensTerm:o}=n(7),{sendTokensTerm:i}=n(8),{setLockedTerm:c}=n(9),{updateTokenDataTerm:u}=n(10),{updateBagDataTerm:l}=n(11),{readBagOrTokenDataTerm:s}=n(12),{readBagsOrTokensDataTerm:p}=n(13),{read:d}=n(14),{readBagsTerm:f}=n(15),{changePriceTerm:y}=n(16);e.exports={version:"4.0.0",mainTerm:a,createTokensTerm:r,purchaseTokensTerm:o,sendTokensTerm:i,setLockedTerm:c,updateTokenDataTerm:u,updateBagDataTerm:l,readBagOrTokenDataTerm:s,readBagsOrTokensDataTerm:p,read:d,readBagsTerm:f,changePriceTerm:y}},function(e,t){e.exports=ReactRedux},function(e,t){e.exports=ReactDOM},function(e,t){e.exports=Redux},function(e,t){e.exports.mainTerm=(e,t)=>`new \n  mainCh,\n\n  createCh,\n  purchaseCh,\n  sendCh,\n  changePriceCh,\n  entryCh,\n  entryUriCh,\n  setLockedCh,\n  updateTokenDataCh,\n  updateBagDataCh,\n  verifySignatureAndUpdateNonceCh,\n  justVerifySignatureCh,\n\n  bags,\n  bagsData,\n  tokensData,\n\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\n  stdout(\`rho:io:stdout\`),\n  secpVerify(\`rho:crypto:secp256k1Verify\`),\n  blake2b256(\`rho:crypto:blake2b256Hash\`),\n  revAddress(\`rho:rev:address\`),\n  registryLookup(\`rho:registry:lookup\`)\nin {\n\n\n  /*\n    bags: {\n      [bagId: String (incremental id)]: {\n        publicKey: String (public key),\n        n: Nil \\/ String (token id),\n        price: Nil \\/ Int\n        quantity: Int\n      }\n    }\n  */\n  bags!({/*DEFAULT_BAGS*/}) |\n\n  /*\n    bagsData: {\n      [bagId: String (bag id)]: Any\n    }\n  */\n  bagsData!({/*DEFAULT_BAGS_DATA*/}) |\n\n  /*\n    tokensData: {\n      [n: Strig (token id)]: String (registry URI)\n    }\n  */\n  tokensData!({/*DEFAULT_TOKENS_DATA*/}) |\n\n  for (@(payload, signature, returnCh) <= verifySignatureAndUpdateNonceCh) {\n    new hashCh, verifySignatureCh in {\n      for (@current <<- mainCh) {\n        blake2b256!(\n          payload.set("nonce", current.get("nonce")).toByteArray(),\n          *hashCh\n        ) |\n        for (@hash <- hashCh) {\n          secpVerify!(\n            hash,\n            signature.hexToBytes(),\n            current.get("publicKey").hexToBytes(),\n            *verifySignatureCh\n          )\n        } |\n        for (@result <- verifySignatureCh) {\n          match result {\n            true => {\n              @returnCh!(true) |\n              for (@c <- mainCh) {\n                mainCh!(c.set("nonce", payload.get("newNonce")))\n              }\n            }\n            false => {\n              @returnCh!("error: Invalid signature, could not perform operation")\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  for (@(publicKey, signature, payload, nonce, returnCh) <= justVerifySignatureCh) {\n    stdout!("justVerifySignatureCh") |\n    new hashCh, verifySignatureCh in {\n      blake2b256!(\n        payload.set("nonce", nonce).toByteArray(),\n        *hashCh\n      ) |\n      for (@hash <- hashCh) {\n        secpVerify!(\n          hash,\n          signature.hexToBytes(),\n          publicKey.hexToBytes(),\n          *verifySignatureCh\n        )\n      } |\n      for (@result <- verifySignatureCh) {\n        @returnCh!(result)\n      }\n    }\n  } |\n\n  contract setLockedCh(payload, signature, return) = {\n    stdout!("setLockedCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is already locked")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              *payload,\n              *signature,\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("locked", true))\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateTokenDataCh(payload, signature, return) = {\n    stdout!("updateTokenDataCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot update token data")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              *payload,\n              *signature,\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentTokensData <- tokensData) {\n                    tokensData!(\n                      currentTokensData.set(*payload.get("n"), *payload.get("data"))\n                    )\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateBagDataCh(payload, signature, return) = {\n    stdout!("updateBagDataCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          new justVerifySignatureReturnCh in {\n            justVerifySignatureCh!((\n              bag.get("publicKey"),\n              *signature,\n              *payload,\n              bag.get("nonce"),\n              *justVerifySignatureReturnCh\n            )) |\n            for (@verified <- justVerifySignatureReturnCh) {\n              match verified {\n                true => {\n                  for (@currentBagsData <- bagsData) {\n                    bagsData!(\n                      currentBagsData.set(*payload.get("bagId"), *payload.get("data"))\n                    ) |\n                    return!(true)\n                  }\n                }\n                err => {\n                  return!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // add a token (1 or more)\n  contract createCh(payload, signature, return) = {\n    stdout!("createCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot create token")\n        }\n        false => {\n          for (@currentBags <<- bags) {\n            new verifyCh in {\n              verifySignatureAndUpdateNonceCh!((\n                *payload,\n                *signature,\n                *verifyCh\n              )) |\n              for (@verified <- verifyCh) {\n                match verified {\n                  true => {\n                    match "\${n}" %% { "n": currentBags.size() } {\n                      bagId => {\n                        for (_ <- bags) {\n                          bags!(\n                            currentBags.set(bagId, {\n                              "quantity": *payload.get("quantity"),\n                              "publicKey": *payload.get("publicKey"),\n                              "nonce": *payload.get("bagNonce"),\n                              "n": *payload.get("n"),\n                              "price": *payload.get("price"),\n                            })\n                          )\n                        } |\n\n                        match *payload.get("data") {\n                          Nil => {}\n                          data => {\n                            for (@currentBagsData <- bagsData) {\n                              bagsData!(\n                                currentBagsData.set(bagId, data)\n                              )\n                            }\n                          }\n                        } |\n\n                        return!(true)\n                      }\n                    }\n                  }\n                  err => {\n                    return!(err)\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // purchase token (1 or more)\n  contract purchaseCh(payload, return) = {\n    stdout!("purchaseCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            false => {\n              return!("error : not enough tokens in bag (bag ID: " ++ *payload.get("bagId") ++ ") available")\n            }\n            true => {\n              new RevVaultCh, ownerRevAddressCh, purseVaultCh in {\n\n                registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n                revAddress!("fromPublicKey", bag.get("publicKey").hexToBytes(), *ownerRevAddressCh) |\n\n                for (@(_, RevVault) <- RevVaultCh; @ownerRevAddress <- ownerRevAddressCh) {\n                  match (\n                    *payload.get("purseRevAddr"),\n                    ownerRevAddress,\n                    *payload.get("quantity") * bag.get("price")\n                  ) {\n                    (from, to, amount) => {\n                      @RevVault!("findOrCreate", from, *purseVaultCh) |\n                      for (@(true, purseVault) <- purseVaultCh) {\n                        new resultCh, performRefundCh in {                        \n                          // refund\n                          for (@message <- performRefundCh) {\n                            new refundPurseBalanceCh, refundRevAddressCh, refundResultCh in {\n                              @purseVault!("balance", *refundPurseBalanceCh) |\n                              revAddress!("fromPublicKey", *payload.get("publicKey").hexToBytes(), *refundRevAddressCh) |\n                              for (@balance <- refundPurseBalanceCh; @revAddress <- refundRevAddressCh) {\n                                @purseVault!("transfer", revAddress, balance, *payload.get("purseAuthKey"), *refundResultCh) |\n                                for (@refundResult <- refundResultCh) {\n                                  match refundResult {\n                                    (true, Nil) => {\n                                      stdout!("refund went well") |\n                                      return!(message ++ ", issuer was refunded")\n                                    }\n                                    _ => {\n                                      stdout!("error: refund DID NOT go well") |\n                                      return!(message ++ ", issuer was NOT refunded")\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          } |\n                          @purseVault!("transfer", to, amount, *payload.get("purseAuthKey"), *resultCh) |\n                          for (@result <- resultCh) {\n                            match result {\n                              (true, Nil) => {\n                                match "\${bagId}" %% { "bagId": currentBags.size() } {\n                                  bagId => {\n                                    match *payload.get("data") {\n                                      Nil => {}\n                                      data => {\n                                        for (@currentBagsData <- bagsData) {\n                                          bagsData!(currentBagsData.set(bagId, data))\n                                        }\n                                      }\n                                    } |\n                                    for (_ <- bags) {\n                                      match bag.get("quantity") - *payload.get("quantity") == 0 {\n                                        true => {\n                                          // todo, should we delete bag data for *payload.get("bagId") here ?\n                                          bags!(\n                                            currentBags.set(bagId, {\n                                              "quantity": *payload.get("quantity"),\n                                              "publicKey": *payload.get("publicKey"),\n                                              "nonce": *payload.get("nonce"),\n                                              "n": bag.get("n"),\n                                              "price": Nil,\n                                            })\n                                            // Delete seller bag\n                                            .delete(*payload.get("bagId"))\n                                          )\n                                        }\n                                        false => {\n                                          bags!(\n                                            currentBags.set(bagId, {\n                                              "quantity": *payload.get("quantity"),\n                                              "publicKey": *payload.get("publicKey"),\n                                              "nonce": *payload.get("nonce"),\n                                              "n": bag.get("n"),\n                                              "price": Nil,\n                                            // Udate quantity in seller token ownership\n                                            }).set(\n                                              *payload.get("bagId"),\n                                              bag.set("quantity", bag.get("quantity") - *payload.get("quantity"))\n                                            )\n                                          )\n                                        }\n                                      } |\n                                      return!(true)\n                                    }\n                                  }\n                                }\n                              }\n                              _ => {\n                                performRefundCh!("error: REV transfer went wrong")\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract sendCh(payload, signature, return) = {\n    stdout!("sendCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            true => {\n              new justVerifySignatureReturnCh in {\n                justVerifySignatureCh!((\n                  bag.get("publicKey"),\n                  *signature,\n                  *payload,\n                  bag.get("nonce"),\n                  *justVerifySignatureReturnCh\n                )) |\n                for (@r <- justVerifySignatureReturnCh) {\n                  match r {\n                    true => {\n                      match "\${bagId}" %% { "bagId": currentBags.size() } {\n                        bagId => {\n                          // Add bag data if found in payload\n                          match *payload.get("data") {\n                            Nil => {}\n                            data => {\n                              for (@currentBagsData <- bagsData) {\n                                bagsData!(currentBagsData.set(bagId, data))\n                              }\n                            }\n                          } |\n                          for (_ <- bags) {\n                            match bag.get("quantity") - *payload.get("quantity") == 0 {\n                              true => {\n                                bags!(\n                                  // todo, should we delete bag data for *payload.get("bagId") here ?\n                                  currentBags.set(bagId, {\n                                    "quantity": *payload.get("quantity"),\n                                    "publicKey": *payload.get("publicKey"),\n                                    "nonce": *payload.get("bagNonce2"),\n                                    "n": bag.get("n"),\n                                    "price": Nil,\n                                  // Delete issuer bag\n                                  }).delete(*payload.get("bagId"))\n                                )\n                              }\n                              false => {\n                                bags!(\n                                  // New bag ID for new bag\n                                  currentBags.set(bagId, {\n                                    "quantity": *payload.get("quantity"),\n                                    "publicKey": *payload.get("publicKey"),\n                                    "nonce": *payload.get("bagNonce2"),\n                                    "n": bag.get("n"),\n                                    "price": Nil,\n                                  // Udate quantity in seller bag\n                                  }).set(\n                                    *payload.get("bagId"),\n                                    bag.set(\n                                      "quantity", bag.get("quantity") - *payload.get("quantity")\n                                    ).set(\n                                      "nonce",\n                                      *payload.get("bagNonce")\n                                    )\n                                  )\n                                )\n                              }\n                            } |\n                            return!(true)\n                          }\n                        }\n                      }\n                    }\n                    false => {\n                      return!("error: Invalid signature, could not perform operation")\n                    }\n                  }\n                }\n              }\n            }\n            false => {\n              return!("error : not enough tokens in bag (bag ID) " ++ *payload.get("bagId") ++ " available")\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract changePriceCh(payload, signature, return) = {\n    stdout!("changePriceCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          new justVerifySignatureReturnCh in {\n            justVerifySignatureCh!((\n              bag.get("publicKey"),\n              *signature,\n              *payload,\n              bag.get("nonce"),\n              *justVerifySignatureReturnCh\n            )) |\n            for (@r <- justVerifySignatureReturnCh) {\n              match r {\n                true => {\n                  for (_ <- bags) {\n                    bags!(\n                      currentBags.set(\n                        *payload.get("bagId"),\n                        bag\n                          .set("price", *payload.get("price"))\n                          .set("nonce", *payload.get("bagNonce"))\n                      )\n                    ) |\n                    return!(true)\n                  }\n                }\n                false => {\n                  return!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n  \n  contract entryCh(action, return) = {\n    match *action.get("type") {\n      // Read capabilities\n      "READ_BAGS" => {\n        for (currentBags <<- bags) {\n          return!(*currentBags)\n        }\n      }\n      "READ_BAGS_DATA" => {\n        for (currentBagsData <<- bagsData) {\n          return!(*currentBagsData)\n        }\n      }\n      "READ_TOKENS_DATA" => {\n        for (@currentTokensData <<- tokensData) {\n          return!(currentTokensData)\n        }\n      }\n      "READ" => {\n        for (current <<- mainCh) {\n          return!(*current)\n        }\n      }\n      // Admin capabilities (require a signature of the nonce)\n      "SET_LOCKED" => {\n        match *action.get("payload") {\n          { "newNonce": String } => {\n            setLockedCh!(\n              *action.get("payload"),\n              *action.get("signature"),\n              *return\n            )\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'newNonce': String, 'locked': Boolean }")\n          }\n        }\n      }\n      "UPDATE_TOKEN_DATA" => {\n        match *action.get("payload") {\n          { "newNonce": String, "n": String, "data": _ } => {\n            updateTokenDataCh!(*action.get("payload"), *action.get("signature"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'newNonce': String, 'n': String, 'data': _ }")\n          }\n        }\n      }\n      "UPDATE_BAG_DATA" => {\n        match *action.get("payload") {\n          { "newNonce": String, "bagId": String, "data": _ } => {\n            updateBagDataCh!(\n              *action.get("payload"),\n              *action.get("signature"),\n              *return\n            )\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'newNonce': String, 'bagId': String, 'data': _ }")\n          }\n        }\n      }\n      "CREATE_TOKENS" => {\n        match *action.get("payload") {\n          {\n            "newNonce": String,\n            "bagNonce": String,\n            "quantity": Int,\n            "publicKey": String,\n            "price": Nil \\/ Int,\n            "n": String,\n            "data": _\n          } => {\n            createCh!(\n              *action.get("payload"),\n              *action.get("signature"),\n              *return\n            )\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'newNonce': String, 'bagNonce': String, 'quantity': Int, 'n': String, 'price': Nil or Int, 'publicKey': String, 'data': Any }")\n          }\n        }\n      }\n      // Anyone capabilities\n      "PURCHASE_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "nonce": String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\n            purchaseCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': String, 'publicKey': String, 'nonce': String, 'data': Any, 'purseRevAddr': String, 'purseAuthKey': AuthKey }")\n          }\n        }\n      }\n      "SEND_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "bagNonce": String, "bagNonce2": String, "data": _, } => {\n            sendCh!(\n              *action.get("payload"),\n              *action.get("signature"),\n              *return\n            )\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': String, 'publicKey': String, 'bagNonce': String, 'bagNonce2': String, 'data': Any }")\n          }\n        }\n      }\n      "CHANGE_PRICE" => {\n        match *action.get("payload") {\n          { "bagId": String, "price": Nil \\/ Int, "bagNonce": String } => {\n            changePriceCh!(\n              *action.get("payload"),\n              *action.get("signature"),\n              *return\n            )\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'price': Nil or Int, 'bagId': String, 'bagNonce': String }")\n          }\n        }\n      }\n      _ => {\n        return!("error: unknown action")\n      }\n    }\n  } |\n\n  insertArbitrary!(bundle+{*entryCh}, *entryUriCh) |\n\n  for (entryUri <- entryUriCh) {\n\n    mainCh!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${t}",\n      "nonce": "${e}",\n      "version": "4.0.0"\n    }) |\n    stdout!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${t}",\n      "nonce": "${e}",\n      "version": "4.0.0"\n    })\n\n    /*OUTPUT_CHANNEL*/\n  }\n}\n`},function(e,t){e.exports.createTokensTerm=(e,t,n)=>`new basket,\n  returnCh,\n  entryCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "CREATE_TOKENS",\n        // signature of the payload + contract nonce in it, with the private key of the owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t.newNonce}",\n          // new nonce for the bag, must be random (generateNonce.js)\n          "bagNonce": "${t.bagNonce}",\n          // per token price, can be Nil if the token is not for sale\n          "price": ${t.price||"Nil"},\n          // The token you create can be a new one ("n" : Nil)\n          // or it can be linked to an existing token data (ex: "n": "0")\n          "n": ${"string"==typeof t.n?'"'+t.n+'"':"Nil"},\n          // quantity of tokens to create\n          "quantity": ${t.quantity},\n          // publicKey this set of tokens (depending on quantity) will belong to\n          "publicKey": "${t.publicKey}", // used only if new token\n          // data you will associated to the new bag (NOT TOKEN DATA)\n          "data": ${t.data?'"'+t.data+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, tokens created")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.purchaseTokensTerm=(e,t)=>`\nnew\n  basket,\n  revVaultPurseCh,\n  priceCh,\n  quantityCh,\n  publicKeyCh,\n  nonceCh,\n  bagDataCh,\n  returnCh,\n  bagIdCh,\n  registryUriCh,\n  revAddressCh,\n  registryLookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`),\n  revAddress(\`rho:rev:address\`)\nin {\n\n  /*\n    The 5 following values must be filled with proper values\n  */ \n  // Registry URI of the contract\n  registryUriCh!!(\`rho:id:${e}\`) |\n  // Unique ID of the token you want to purchase\n  bagIdCh!!("${t.bagId}") |\n  // Per token price, make sure it is accurate\n  priceCh!!(${t.price||"Nil"}) |\n  // Bag data: Any\n  bagDataCh!!(${t.data?'"'+t.data+'"':"Nil"}) |\n  // Quantity you want to purchase, make sure enough are available\n  quantityCh!!(${t.quantity}) |\n  // Your public key\n  // If the transfer fails, refund will go to the corresponding REV address\n  publicKeyCh!!("${t.publicKey}") |\n  // A unique nonce to be changed on each operation\n  nonceCh!!("${t.bagNonce}") |\n\n  registryLookup!(\`rho:rchain:revVault\`, *revVaultPurseCh) |\n\n  /*\n    Create a vault/purse that is just used once (purse)\n  */\n  for(@(_, *RevVaultPurse) <- revVaultPurseCh) {\n    new unf, purseRevAddrCh, purseAuthKeyCh, vaultCh, revAddressCh in {\n      revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |\n      RevVaultPurse!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |\n      for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {\n\n        stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |\n\n        RevVaultPurse!("findOrCreate", purseRevAddr, *vaultCh) |\n\n        for (\n          @(true, *vault) <- vaultCh;\n          @publicKey <- publicKeyCh;\n          @nonce <- nonceCh;\n          @bagId <- bagIdCh;\n          @registryUri <- registryUriCh;\n          @price <- priceCh;\n          @bagData <- bagDataCh;\n          @quantity <- quantityCh\n        ) {\n\n          revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |\n\n          new RevVaultCh in {\n\n            registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n            for (@(_, RevVault) <- RevVaultCh; deployerRevAddress <- revAddressCh) {\n\n              stdout!(("3.transfer_funds.rho")) |\n\n              /*\n                Put price * quantity REV in the purse\n              */\n              match (\n                *deployerRevAddress,\n                purseRevAddr,\n                price * quantity\n              ) {\n                (from, to, amount) => {\n\n                  new vaultCh, revVaultkeyCh, deployerId(\`rho:rchain:deployerId\`) in {\n                    @RevVault!("findOrCreate", from, *vaultCh) |\n                    @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |\n                    for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {\n\n                      stdout!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |\n\n                      new resultCh, entryCh in {\n                        @vault!("transfer", to, amount, *key, *resultCh) |\n                        for (@result <- resultCh) {\n\n                          stdout!(("Finished transfer of ", amount, "REV to", to, "result was:", result)) |\n                          match result {\n                            (true, Nil) => {\n                              stdout!("yes") |\n                              registryLookup!(registryUri, *entryCh) |\n\n                              for(entry <- entryCh) {\n                                stdout!(("GET ENTRY", *entry)) |\n                                entry!(\n                                  {\n                                    "type": "PURCHASE_TOKENS",\n                                    "payload": {\n                                      "quantity": quantity,\n                                      "bagId": bagId,\n                                      "data": bagData,\n                                      "nonce": nonce,\n                                      "publicKey": publicKey,\n                                      "purseRevAddr": purseRevAddr,\n                                      "purseAuthKey": purseAuthKey\n                                    }\n                                  },\n                                  *returnCh\n                                ) |\n                                for (resp <- returnCh) {\n                                  match *resp {\n                                    true => {\n                                      basket!({ "status": "completed" }) |\n                                      stdout!("completed, tokens purchased")\n                                    }\n                                    _ => {\n                                      basket!({ "status": "failed", "message": *resp }) |\n                                      stdout!(("failed", *resp))\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                            _ => {\n                              basket!({ "status": "failed", "message": result }) |\n                              stdout!(("failed", result))\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.sendTokensTerm=(e,t,n)=>`new basket,\n  returnCh,\n  entryCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SEND_TOKENS",\n        // signature of the payload + bag nonce in it, with the private key of the bag owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "bagNonce": "${t.bagNonce}",\n          // new nonce for the new bag\n          "bagNonce2": "${t.bagNonce2}",\n          // bag ID (ex: "0")\n          "bagId": "${t.bagId}",\n          // quantity of tokens to send\n          "quantity": ${t.quantity},\n          // publicKey this send those tokens to (can be the same just split a bag)\n          "publicKey": "${t.publicKey}",\n          // data (optional) to be attached to the new bag (in bagsData)\n          "data": ${t.data?'"'+t.data+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, tokens send")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.setLockedTerm=(e,t,n)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SET_LOCKED",\n        // signature of the payload + contract nonce in it, with the private key of the owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t.newNonce}",\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, contract locked")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.updateTokenDataTerm=(e,t,n)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_TOKEN_DATA",\n        // signature of the payload + contract nonce in it, with the private key of the owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t.newNonce}",\n          // token ID you want to attach data to\n          "n": ${"string"==typeof t.n?'"'+t.n+'"':"Nil"},\n          // data is used only if new token ("n" : Nil)\n          "data": ${t.data?'"'+t.data+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, data updated")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.updateBagDataTerm=(e,t,n)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_BAG_DATA",\n        // signature of the payload + bag nonce in it, with the private key of the bag owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t.newNonce}",\n          // bag ID you want to attach data to\n          "bagId": "${t.bagId}",\n          // data is used only if new token ("n" : Nil)\n          "data": ${t.data?'"'+t.data+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, data updated")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.readBagOrTokenDataTerm=(e,t,n)=>`new return, entryCh, readCh, lookup(\`rho:registry:lookup\`) in {\n    lookup!(\`rho:id:${e}\`, *entryCh) |\n    for(entry <- entryCh) {\n      new x in {\n        entry!({ "type": "${"tokens"===t?"READ_TOKENS_DATA":"READ_BAGS_DATA"}" }, *x) |\n        for (y <- x) {\n          return!(*y.get("${n}"))\n        }\n      }\n    }\n  }`},function(e,t){e.exports.readBagsOrTokensDataTerm=(e,t)=>`new return, entryCh, readCh, lookup(\`rho:registry:lookup\`) in {\n    lookup!(\`rho:id:${e}\`, *entryCh) |\n    for(entry <- entryCh) {\n      new x in {\n        entry!({ "type": "${"tokens"===t?"READ_TOKENS_DATA":"READ_BAGS_DATA"}" }, *x) |\n        for (y <- x) {\n          return!(*y)\n        }\n      }\n    }\n  }`},function(e,t){e.exports.read=e=>`new return, entryCh, readCh, lookup(\`rho:registry:lookup\`) in {\n    lookup!(\`rho:id:${e}\`, *entryCh) |\n    for(entry <- entryCh) {\n      new x in {\n        entry!({ "type": "READ" }, *x) |\n        for (y <- x) {\n          return!(*y)\n        }\n      }\n    }\n  }`},function(e,t){e.exports.readBagsTerm=e=>`new return, entryCh, readCh, lookup(\`rho:registry:lookup\`) in {\n    lookup!(\`rho:id:${e}\`, *entryCh) |\n    for(entry <- entryCh) {\n      new x in {\n        entry!({ "type": "READ_BAGS" }, *x) |\n        for (y <- x) {\n          return!(*y)\n        }\n      }\n    }\n  }`},function(e,t){e.exports.changePriceTerm=(e,t,n)=>`new basket,\n  returnCh,\n  entryCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "CHANGE_PRICE",\n        // signature of the payload + bag nonce in it, with the private key of the bag owner (generateSignatureForNonce.js)\n        "signature": "${n}",\n        "payload": {\n          // new nonce, must be different and random (generateNonce.js)\n          "bagNonce": "${t.bagNonce}",\n          // bag ID (ex: "0")\n          "bagId": "${t.bagId}",\n          // quantity of tokens to send\n          "price": ${t.price||"Nil"},\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      true => {\n        basket!({ "status": "completed" }) |\n        stdout!("completed, bag price changed")\n      }\n      _ => {\n        basket!({ "status": "failed", "message": *resp }) |\n        stdout!(("failed", *resp))\n      }\n    }\n  }\n}\n`},function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),o=n(3),i=n.n(o),c=n(2),u=n(4);function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){p(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var d={registryUri:void 0,publicKey:void 0,nonce:void 0,tokensData:void 0,bags:void 0,bagsData:void 0,tab:void 0,loading:!1},f=Object(u.createStore)((function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d,t=arguments.length>1?arguments[1]:void 0;switch(console.log(t),t.type){case"INIT":return s(s({},e),{},{registryUri:t.payload.registryUri,publicKey:t.payload.publicKey});case"SET_LOADING":return s(s({},e),{},{loading:t.payload});case"INIT_TOKEN":return s(s({},e),{},{publicKey:t.payload.publicKey,locked:t.payload.locked,nonce:t.payload.nonce,tokensData:t.payload.tokensData,bags:t.payload.bags,bagsData:t.payload.bagsData,loading:!1});case"UPDATE_NONCE":return s(s({},e),{},{nonce:t.payload});case"CHANGE_TAB":return s(s({},e),{},{tab:t.payload});case"IDENTIFIED":return s(s({},e),{},{identified:!0});case"UPDATE_NONCE":return s(s({},e),{},{nonce:t.payload});default:return e}})),y=n(1);function g(e){return(g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function b(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function h(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function m(e,t){return(m=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function v(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=C(e);if(t){var r=C(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return k(this,n)}}function k(e,t){return!t||"object"!==g(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function C(e){return(C=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var E=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&m(e,t)}(i,e);var t,n,a,o=v(i);function i(){return b(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return!this.registryUri&&this.props.registryUri&&(this.registryUri=this.props.registryUri),r.a.createElement("div",{className:"form horizontal form-horizontal"},r.a.createElement("div",{className:"field"},r.a.createElement("div",{className:"control"},r.a.createElement("input",{onChange:function(t){return e.registryUri=t.target.value},className:"input registry-uri-input",type:"text",placeholder:"Registry URI",defaultValue:this.props.registryUri}),this.props.loading?r.a.createElement("button",{disabled:!0,type:"button",className:"button is-light"},"Loading"):r.a.createElement("button",{onClick:function(){e.props.loadToken({registryUri:e.registryUri})},type:"button",className:"button is-light"},this.props.registryUri?"Reload":"Load"))))}}])&&h(t.prototype,n),a&&h(t,a),i}(r.a.Component);function N(e){return(N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function w(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function S(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function T(e,t){return(T=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function D(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=R(e);if(t){var r=R(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return O(this,n)}}function O(e,t){return!t||"object"!==N(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function R(e){return(R=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var _=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&T(e,t)}(c,e);var t,n,o,i=D(c);function c(){return w(this,c),i.apply(this,arguments)}return t=c,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,!0===this.props.locked?r.a.createElement(a.Fragment,null,r.a.createElement("h4",{className:"title is-5 locked-t"},"This contract is"," ",r.a.createElement("span",{className:"tag is-success is-medium"},"locked")),r.a.createElement("p",{className:"locked-p"},"The owner cannot add tokens or change existing tokens data anymore.",r.a.createElement("br",null),r.a.createElement("br",null))):void 0,!1===this.props.locked?r.a.createElement(a.Fragment,null,r.a.createElement("h4",{className:"title is-5 locked-t"},"This contract is"," ",r.a.createElement("span",{className:"tag is-danger is-medium"},"not locked")),r.a.createElement("p",{className:"locked-p"},"The owner ",r.a.createElement("b",null,this.props.publicKey)," can still add tokens, and change existing tokens data.",r.a.createElement("br",null),r.a.createElement("br",null))):void 0,r.a.createElement("b",null,"Tokens data"),r.a.createElement("div",{className:"tokens-data"},Object.keys(this.props.tokensData).map((function(t){return r.a.createElement(a.Fragment,{key:t},r.a.createElement("span",null,t," (token ID):"," ",e.props.tokensData[t].length>200?"".concat(e.props.tokensData[t].substr(0,200),"..."):e.props.tokensData[t]),r.a.createElement("hr",null))}))),r.a.createElement("b",null,"Token ownerships / bags"),r.a.createElement("div",{className:"bags"},Object.keys(this.props.bags).map((function(t){return r.a.createElement(a.Fragment,{key:t},r.a.createElement("div",{className:"bag"},r.a.createElement("span",null,"token ID : ",e.props.bags[t].n),r.a.createElement("span",null,"bag ID : ",t),r.a.createElement("span",null,"quantity : ",e.props.bags[t].quantity),r.a.createElement("span",null,"public key : ",e.props.bags[t].publicKey),r.a.createElement("span",null,"price (per token) : ",e.props.bags[t].price)),r.a.createElement("hr",null))}))))}}])&&S(t.prototype,n),o&&S(t,o),c}(r.a.Component);function I(e){return(I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function A(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function j(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function U(e,t){return(U=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function P(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=B(e);if(t){var r=B(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return K(this,n)}}function K(e,t){return!t||"object"!==I(t)&&"function"!=typeof t?x(e):t}function x(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function B(e){return(B=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function q(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var V=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&U(e,t)}(i,e);var t,n,a,o=P(i);function i(){var e;A(this,i);for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return q(x(e=o.call.apply(o,[this].concat(n))),"state",{n:0}),q(x(e),"reload",(function(t){t.preventDefault(),e.setState({n:e.state.n+1})})),e}return t=i,(n=[{key:"render",value:function(){if("undefined"==typeof dappyStore)return console.warn("window.dappyStore is undefined, cannot lock contract"),r.a.createElement("div",null);var e=dappyStore.getState().transactions;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Transactions"," ",r.a.createElement("button",{className:"button is-light is-small",onClick:this.reload},"Reload")),r.a.createElement("p",null,"If you deployed a new ERC-1155 contract, reload this section until see the registry URI displayed."),r.a.createElement("br",null),r.a.createElement("ul",null,Object.keys(e).map((function(t){var n;return console.log(e[t]),"string"==typeof e[t].value?n=e[t].value:e[t].value.registryUri?n="registry URI : ".concat(e[t].value.registryUri.replace("rho:id:","")):e[t].value.status&&(n="status : ".concat(e[t].value.status)),r.a.createElement("li",{key:t},t,": ",n)}))))}}])&&j(t.prototype,n),a&&j(t,a),i}(r.a.Component);function $(e){return($="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function G(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function L(e,t){return(L=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function H(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=z(e);if(t){var r=z(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return F(this,n)}}function F(e,t){return!t||"object"!==$(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function z(e){return(z=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var J='{ "name": "pizza regina" }',M=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&L(e,t)}(i,e);var t,n,a,o=H(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).textarea=r.a.createRef(),t.state={token:void 0,data:J},t}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Update token data"),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Token to update"),r.a.createElement("div",{className:"control"},r.a.createElement("div",{class:"select"},r.a.createElement("select",{onChange:function(t){"Select a token"===t.target.value?(e.textarea.current.value="",e.setState({token:void 0})):(console.log(e.textarea.current),e.textarea.current.value=e.props.tokensData[t.target.value],e.setState({token:t.target.value,data:e.props.tokensData[t.target.value]}))}},r.a.createElement("option",{value:void 0},"Select a token"),Object.keys(this.props.tokensData).map((function(t){return r.a.createElement("option",{disabled:0===e.props.tokensData[t],key:t,value:t},t)})))))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Data"),r.a.createElement("p",{className:"note"},r.a.createElement("b",null,"Note: "),"Data will be stored as a string, and secured with"," ",r.a.createElement("b",null,"encodeURI()")),r.a.createElement("div",{className:"control"},r.a.createElement("textarea",{className:"textarea",ref:this.textarea,onChange:function(t){e.setState({data:t.target.value})},defaultValue:J}))),r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.token,onClick:function(t){e.props.updateTokenData({registryUri:e.props.registryUri,n:e.state.token,data:e.state.data})}},"Update data")))}}])&&G(t.prototype,n),a&&G(t,a),i}(r.a.Component);function Q(e){return(Q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Y(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function W(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function X(e,t){return(X=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Z(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=ne(e);if(t){var r=ne(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return ee(this,n)}}function ee(e,t){return!t||"object"!==Q(t)&&"function"!=typeof t?te(e):t}function te(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function ne(e){return(ne=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function ae(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var re=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&X(e,t)}(i,e);var t,n,a,o=Z(i);function i(){var e;Y(this,i);for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return ae(te(e=o.call.apply(o,[this].concat(n))),"state",{n:"pizza",price:1,quantity:10,data:J}),e}return t=i,(n=[{key:"render",value:function(){var e=this;return console.log(this.state),r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Create token(s)"),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Data (token data)"),r.a.createElement("div",{className:"control"},r.a.createElement("textarea",{className:"textarea",onChange:function(t){e.setState({data:t.target.value})},defaultValue:J}))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Token ID / token type"),r.a.createElement("div",{className:"control"},r.a.createElement("input",{className:"input",onChange:function(t){return e.setState({n:t.target.value})},type:"text",defaultValue:"pizza"}))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Price (dusts)"),r.a.createElement("div",{className:"control"},r.a.createElement("input",{className:"input",onChange:function(t){return e.setState({price:parseInt(t.target.value)})},type:"number",placeholder:"1",step:1,min:1,defaultValue:1}))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Quantity"),r.a.createElement("div",{className:"control"},r.a.createElement("input",{className:"input",onChange:function(t){return e.setState({quantity:parseInt(t.target.value)})},type:"number",placeholder:"10",step:1,min:0,defaultValue:10}))),"number"==typeof this.state.quantity&&"number"==typeof this.state.price?r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Bag total value (dusts) ",this.state.price*this.state.quantity)):void 0,r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-light",type:"button",onClick:function(t){e.props.createToken({registryUri:e.props.registryUri,n:e.state.n,data:e.state.data||void 0,price:e.state.price,quantity:e.state.quantity})}},"Create token(s)")))}}])&&W(t.prototype,n),a&&W(t,a),i}(r.a.Component);function oe(e){return(oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ie(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function ce(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function ue(e,t){return(ue=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function le(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=pe(e);if(t){var r=pe(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return se(this,n)}}function se(e,t){return!t||"object"!==oe(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function pe(e){return(pe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var de=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&ue(e,t)}(i,e);var t,n,a,o=le(i);function i(){return ie(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Lock contract"),r.a.createElement("article",{className:"message is-danger"},r.a.createElement("div",{className:"message-body"},"If you lock the contract, the tokens currently existing will be the only ones to ever exist for this contract. The only available operations available will be :",r.a.createElement("ul",null,r.a.createElement("li",null,"- Send tokens (as the owner of a bag)."),r.a.createElement("li",null,"- Defining a price for tokens in a bag (as the owner of a bag)."),r.a.createElement("li",null,"- Update data associated to a bag (as the owner of a bag)."),r.a.createElement("li",null,"- Buy a set of tokens from a bag.")))),r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-danger",type:"button",onClick:function(t){e.props.setLocked({registryUri:e.props.registryUri})}},"Lock contract")))}}])&&ce(t.prototype,n),a&&ce(t,a),i}(r.a.Component);function fe(e){return(fe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ye(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ge(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function be(e,t){return(be=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function he(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=ve(e);if(t){var r=ve(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return me(this,n)}}function me(e,t){return!t||"object"!==fe(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function ve(e){return(ve=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var ke=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&be(e,t)}(i,e);var t,n,a,o=he(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).state={bagId:void 0,publicKey:""},t}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Send token(s)"),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"From (bag you own)"),r.a.createElement("div",{className:"control"},r.a.createElement("div",{class:"select"},r.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?e.setState({bagId:void 0}):e.setState({bagId:t.target.value})}},r.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).map((function(t){return r.a.createElement("option",{disabled:0===e.props.bags[t],key:t,value:t},t)})))))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"To (public key)"),r.a.createElement("div",{className:"control"},r.a.createElement("input",{className:"input",type:"text",onInput:function(t){e.setState({publicKey:t.target.value})}}))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Amount / Quantity of tokens to send"),this.state.bagId?r.a.createElement("p",{className:"text-warning"},"The selected bag contains"," ",this.props.bags[this.state.bagId].quantity," token(s)"):void 0,r.a.createElement("div",{className:"control"},r.a.createElement("input",{type:"number",className:"input",min:0,onInput:function(t){e.setState({quantity:parseInt(t.target.value)})}}))),r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.bagId||"number"!=typeof this.state.quantity,onClick:function(t){var n;e.props.sendTokens((ye(n={publicKey:e.props.publicKey,registryUri:e.props.registryUri},"publicKey",e.state.publicKey),ye(n,"nonce",e.props.bags[e.state.bagId].nonce),ye(n,"bagId",e.state.bagId),ye(n,"quantity",e.state.quantity),n))}},"Send token(s)")))}}])&&ge(t.prototype,n),a&&ge(t,a),i}(r.a.Component);function Ce(e){return(Ce="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ee(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Ne(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function we(e,t){return(we=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Se(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=Oe(e);if(t){var r=Oe(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return Te(this,n)}}function Te(e,t){return!t||"object"!==Ce(t)&&"function"!=typeof t?De(e):t}function De(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function Oe(e){return(Oe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Re(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var _e=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&we(e,t)}(i,e);var t,n,a,o=Se(i);function i(){var e;Ee(this,i);for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];return Re(De(e=o.call.apply(o,[this].concat(n))),"state",{bagId:void 0,quantity:0,data:""}),e}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Purchase token(s)"),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Token ownership / bag to buy from"),r.a.createElement("div",{className:"control"},r.a.createElement("div",{class:"select"},r.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?e.setState({bagId:void 0}):e.setState({bagId:t.target.value})}},r.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).filter((function(t){return"number"==typeof e.props.bags[t].price})).map((function(t){return r.a.createElement("option",{disabled:0===e.props.bags[t],key:t,value:t},t)})))))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Quantity","string"==typeof this.state.bagId?"(available: ".concat(this.props.bags[this.state.bagId].quantity,")"):""),r.a.createElement("div",{className:"control"},r.a.createElement("input",{className:"input",onChange:function(t){return e.setState({quantity:parseInt(t.target.value)})},type:"number",placeholder:"1",step:1,min:0}))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Data (token data)"),r.a.createElement("div",{className:"control"},r.a.createElement("textarea",{className:"textarea",onChange:function(t){e.setState({data:t.target.value})},defaultValue:""}))),"string"==typeof this.state.bagId?r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Price (total)"," ",this.props.bags[this.state.bagId].price*this.state.quantity)):void 0,r.a.createElement("div",{className:"field"},r.a.createElement("button",{disabled:"string"!=typeof this.state.bagId||!this.state.quantity,className:"button is-light",type:"button",onClick:function(t){e.props.purchaseToken({publicKey:e.props.publicKey,registryUri:e.props.registryUri,bagId:e.state.bagId,data:e.state.data,price:e.props.bags[e.state.bagId].price,quantity:e.state.quantity})}},"Purchase token(s)")))}}])&&Ne(t.prototype,n),a&&Ne(t,a),i}(r.a.Component);function Ie(e){return(Ie="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ae(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function je(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function Ue(e,t){return(Ue=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Pe(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=xe(e);if(t){var r=xe(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return Ke(this,n)}}function Ke(e,t){return!t||"object"!==Ie(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function xe(e){return(xe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Be=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Ue(e,t)}(i,e);var t,n,a,o=Pe(i);function i(){return Ae(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Deploy new ERC-1155 contract"),r.a.createElement("p",null,"After deployment, go in the ",r.a.createElement("u",null,"Transactions")," section and wait for the registry URI to pop.",r.a.createElement("br",null),r.a.createElement("br",null)),r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-medium is-primary",type:"button",onClick:function(t){e.props.deploy({publicKey:e.props.publicKey})}},"Deploy")))}}])&&je(t.prototype,n),a&&je(t,a),i}(r.a.Component);function qe(e){return(qe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ve(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function $e(e,t){return($e=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Ge(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=He(e);if(t){var r=He(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return Le(this,n)}}function Le(e,t){return!t||"object"!==qe(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function He(e){return(He=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Fe=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&$e(e,t)}(i,e);var t,n,a,o=Ge(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).textarea=r.a.createRef(),t.state={bagId:void 0,data:'{ "color": "blue" }'},t}return t=i,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("h4",{className:"title is-4"},"Update bag data"),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Token ownership / bag to update"),r.a.createElement("div",{className:"control"},r.a.createElement("div",{class:"select"},r.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?(e.textarea.current.value="",e.setState({bagId:void 0})):(e.props.bagsData[t.target.value]?e.textarea.current.value=e.props.bagsData[t.target.value]:e.textarea.current.value="",e.setState({bagId:t.target.value,data:e.props.bagsData[t.target.value]||""}))}},r.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).map((function(t){return r.a.createElement("option",{disabled:0===e.props.bagsData[t],key:t,value:t},t)})))))),r.a.createElement("div",{className:"field"},r.a.createElement("label",{className:"label"},"Data"),r.a.createElement("p",{className:"note"},r.a.createElement("b",null,"Note: "),"Data will be stored as a string, and secured with"," ",r.a.createElement("b",null,"encodeURI()")),r.a.createElement("div",{className:"control"},r.a.createElement("textarea",{className:"textarea",ref:this.textarea,onInput:function(t){e.setState({data:t.target.value})},defaultValue:'{ "color": "blue" }'}))),r.a.createElement("div",{className:"field"},r.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.bagId,onClick:function(t){e.props.updateBagData({registryUri:e.props.registryUri,nonce:e.props.bags[e.state.bagId].nonce,bagId:e.state.bagId,data:e.state.data})}},"Update data")))}}])&&Ve(t.prototype,n),a&&Ve(t,a),i}(r.a.Component);function ze(e){return(ze="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Je(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Me(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function Qe(e,t){return(Qe=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Ye(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=Xe(e);if(t){var r=Xe(this).constructor;n=Reflect.construct(a,arguments,r)}else n=a.apply(this,arguments);return We(this,n)}}function We(e,t){return!t||"object"!==ze(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Xe(e){return(Xe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Ze=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Qe(e,t)}(c,e);var t,n,o,i=Ye(c);function c(){return Je(this,c),i.apply(this,arguments)}return t=c,(n=[{key:"render",value:function(){var e=this;return r.a.createElement("div",null,r.a.createElement("b",null,"Bags data"),r.a.createElement("div",{className:"tokens-data"},Object.keys(this.props.bagsData).map((function(t){return r.a.createElement(a.Fragment,{key:t},r.a.createElement("span",null,t," (bag ID) :"," ",e.props.bagsData[t].length>200?"".concat(e.props.bagsData[t].substr(0,200),"..."):e.props.bagsData[t]),r.a.createElement("hr",null))}))))}}])&&Me(t.prototype,n),o&&Me(t,o),c}(r.a.Component);function et(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var n=[],a=!0,r=!1,o=void 0;try{for(var i,c=e[Symbol.iterator]();!(a=(i=c.next()).done)&&(n.push(i.value),!t||n.length!==t);a=!0);}catch(e){r=!0,o=e}finally{try{a||null==c.return||c.return()}finally{if(r)throw o}}return n}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return tt(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return tt(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function tt(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=new Array(t);n<t;n++)a[n]=e[n];return a}var nt=Object(c.connect)((function(e){return{loading:e.loading,tokensData:e.tokensData,bags:e.bags,bagsData:e.bagsData,tab:e.tab,registryUri:e.registryUri,nonce:e.nonce,publicKey:e.publicKey,locked:e.locked}}),(function(e,t){return{goCreateToken:function(){e({type:"CHANGE_TAB",payload:"creatingToken"})},goUpdateTokenData:function(){e({type:"CHANGE_TAB",payload:"updatingTokenData"})},goUpdateBagData:function(){e({type:"CHANGE_TAB",payload:"updatingBagData"})},goSeeBagsData:function(){e({type:"CHANGE_TAB",payload:"seeingBagsData"})},goPurchase:function(){e({type:"CHANGE_TAB",payload:"purchasing"})},goDashboard:function(){e({type:"CHANGE_TAB",payload:void 0})},goDeploy:function(){e({type:"CHANGE_TAB",payload:"deploying"})},goSend:function(){e({type:"CHANGE_TAB",payload:"sending"})},goTransactions:function(){e({type:"CHANGE_TAB",payload:"transactions"})},goSetLocked:function(){e({type:"CHANGE_TAB",payload:"locking"})},setLocked:function(n){console.log(n);var a=blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var r={nonce:t.nonce,newNonce:a},o=blockchainUtils.toByteArray(r),i=Object(y.setLockedTerm)(n.registryUri,r,"SIGN");dappyRChain.transaction({term:i,signatures:{SIGN:blockchainUtils.uInt8ArrayToHex(o)}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:a})}))}else console.warn("window.dappyRChain is undefined, cannot lock contract")},updateTokenData:function(n){console.log(n);var a=blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var r={nonce:t.nonce,newNonce:a,n:n.n,data:n.data?encodeURI(n.data):void 0},o=blockchainUtils.toByteArray(r),i=Object(y.updateTokenDataTerm)(n.registryUri,r,"SIGN");dappyRChain.transaction({term:i,signatures:{SIGN:blockchainUtils.uInt8ArrayToHex(o)}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:blockchainUtils.uInt8ArrayToHex(o)})}))}else console.warn("window.dappyRChain is undefined, cannot create token")},updateBagData:function(e){console.log(e);blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var t={nonce:getNonce(),newNonce:e.newNonce,bagId:e.bagId,data:e.data?encodeURI(e.data):void 0},n=blockchainUtils.toByteArray(t),a=Object(y.updateBagDataTerm)(e.registryUri,t,"SIGN");dappyRChain.transaction({term:a,signatures:{SIGN:blockchainUtils.uInt8ArrayToHex(n)}}).then((function(e){console.log(e)}))}else console.warn("window.dappyRChain is undefined, cannot create token")},sendTokens:function(e){console.log(e);var t=blockchainUtils.generateNonce(),n=blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var a={nonce:getNonce(),bagNonce:t,bagNonce2:n,bagId:e.bagId,quantity:e.quantity,publicKey:e.publicKey,data:void 0},r=blockchainUtils.toByteArray(a),o=Object(y.sendTokensTerm)(e.registryUri,a,"SIGN");dappyRChain.transaction({term:o,signatures:{SIGN:blockchainUtils.uInt8ArrayToHex(r)}}).then((function(e){console.log(e)}))}else console.warn("window.dappyRChain is undefined, cannot create token")},createToken:function(n){console.log("OWNPROPD",t),console.log(n);var a=blockchainUtils.generateNonce(),r=blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var o={nonce:t.nonce,bagNonce:r,publicKey:n.publicKey,data:n.data?encodeURI(n.data):void 0,n:n.n,newNonce:a,price:n.price,quantity:n.quantity};console.log("----------------------------"),console.log(o);var i=blockchainUtils.toByteArray(o),c=Object(y.createTokensTerm)(n.registryUri,o,"SIGN");dappyRChain.transaction({term:c,signatures:{SIGN:blockchainUtils.uInt8ArrayToHex(i)}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:a})}))}else console.warn("window.dappyRChain is undefined, cannot create token")},purchaseToken:function(e){console.log(e);var t=blockchainUtils.generateNonce();if("undefined"!=typeof dappyRChain){var n=Object(y.purchaseTokensTerm)(e.registryUri,{publicKey:e.publicKey,bagId:e.bagId,quantity:e.quantity,price:e.price,bagNonce:t,data:e.data});dappyRChain.transaction({term:n,signatures:{}}).then((function(e){console.log(e)}))}else console.warn("window.dappyRChain is undefined, cannot purchase token")},loadToken:function(t){var n;(console.log(t),"undefined"!=typeof dappyRChain)?(e({type:"SET_LOADING",payload:!0}),(n=t.registryUri,new Promise((function(e,t){dappyRChain.exploreDeploys([Object(y.read)(n),Object(y.readBagsOrTokensDataTerm)(n,"tokens"),Object(y.readBagsOrTokensDataTerm)(n,"bags"),Object(y.readBagsTerm)(n)]).then((function(t){var n=JSON.parse(t).results,a=blockchainUtils.rhoValToJs(JSON.parse(n[0].data).expr[0]),r=a.nonce,o=a.locked,i=a.publicKey,c=blockchainUtils.rhoValToJs(JSON.parse(n[1].data).expr[0]);console.log("tokensData"),console.log(c);var u={};Object.keys(c).forEach((function(e){u[e]=decodeURI(c[e])}));var l=blockchainUtils.rhoValToJs(JSON.parse(n[3].data).expr[0]);console.log("bags"),console.log(l);var s=blockchainUtils.rhoValToJs(JSON.parse(n[2].data).expr[0]);console.log("bagsData"),console.log(s);var p={};Object.keys(s).forEach((function(e){p[e]=decodeURI(s[e])})),e({publicKey:i,nonce:r,locked:o,tokensData:u,bags:l,bagsData:p})})).catch((function(e){t(e)}))}))).then((function(t){e({type:"INIT_TOKEN",payload:t})})).catch((function(e){console.error("Something went wrong when loading data"),console.log(e)}))):console.warn("window.dappyRChain is undefined, cannot fetch data")},deploy:function(t){var n=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.mainTerm)(n,t.publicKey),signatures:{}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:n})})):console.warn("window.dappyRChain is undefined, cannot create token")}}}))((function(e){var t=et(Object(a.useState)(void 0),2),n=t[0],o=t[1],i=e.bags&&e.tokensData&&e.registryUri,c=void 0===e.tab;return r.a.createElement("div",{className:"container"},r.a.createElement("h2",{className:"title is-2"},"ERC 1155 manager"),r.a.createElement("div",{className:"columns left-menu"},r.a.createElement("div",{className:"column is-one-quarter"},r.a.createElement("div",{className:"menu"},r.a.createElement("ul",{className:"menu-list"},r.a.createElement("li",null," ",r.a.createElement("a",{className:"",onClick:function(t){e.goDashboard()}},"Dashboard")),r.a.createElement("li",null," ",r.a.createElement("a",{className:"",onClick:function(t){e.goDeploy()}},"Deploy")),r.a.createElement("li",null," ",r.a.createElement("a",{className:"",onClick:function(t){e.goTransactions()}},"Transactions")),i?r.a.createElement(a.Fragment,null,r.a.createElement("li",null,r.a.createElement("a",{onClick:function(t){e.goPurchase()}},"Purchase token(s)")),r.a.createElement("li",null,r.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot create token",onClick:function(t){e.locked||e.goCreateToken()}},"Create token(s)")),r.a.createElement("li",null,r.a.createElement("a",{onClick:function(t){e.goSend()}},"Send token(s)")),r.a.createElement("li",null,r.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot update token data",onClick:function(t){e.locked||e.goUpdateTokenData()}},"Update token data")),r.a.createElement("li",null,r.a.createElement("a",{onClick:function(t){e.goUpdateBagData()}},"Update bag data")),r.a.createElement("li",null,r.a.createElement("a",{onClick:function(t){e.goSeeBagsData()}},"See bags data")),r.a.createElement("li",null,r.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot lock",onClick:function(t){e.locked||e.goSetLocked()}},"Lock contract"))):void 0))),r.a.createElement("div",{className:"column is-three-quarters"},c?r.a.createElement(E,{loadToken:function(t){o(t.registryUri),e.loadToken(t)},registryUri:n,loading:e.loading}):void 0,"transactions"===e.tab?r.a.createElement(V,null):void 0,"creatingToken"===e.tab?r.a.createElement(re,{registryUri:n,createToken:e.createToken}):void 0,"sending"===e.tab?r.a.createElement(ke,{registryUri:n,bags:e.bags,publicKey:e.publicKey,sendTokens:e.sendTokens}):void 0,"purchasing"===e.tab?r.a.createElement(_e,{registryUri:n,purchaseToken:e.purchaseToken,publicKey:e.publicKey,bags:e.bags}):void 0,"updatingTokenData"===e.tab?r.a.createElement(M,{registryUri:n,updateTokenData:e.updateTokenData,tokensData:e.tokensData}):void 0,"seeingBagsData"===e.tab?r.a.createElement(Ze,{bagsData:e.bagsData}):void 0,"updatingBagData"===e.tab?r.a.createElement(Fe,{registryUri:n,updateBagData:e.updateBagData,bagsData:e.bagsData,bags:e.bags}):void 0,"locking"===e.tab?r.a.createElement(de,{registryUri:n,setLocked:e.setLocked}):void 0,"deploying"===e.tab?r.a.createElement(Be,{deploy:e.deploy,publicKey:e.publicKey}):void 0,i&&c?r.a.createElement(_,{tokensData:e.tokensData,bags:e.bags,publicKey:e.publicKey,locked:e.locked}):void 0)))})),at=function(){return r.a.createElement(c.Provider,{store:f},r.a.createElement(nt,null))};window.onload=function(){i.a.render(r.a.createElement(at,null),document.getElementById("root"))},"undefined"!=typeof dappyRChain&&dappyRChain.fetch("dappy://REGISTRY_URI").then((function(e){var t=JSON.parse(e).expr[0],n=blockchainUtils.rhoValToJs(t);console.log(n),dappyRChain.identify({publicKey:void 0}).then((function(e){e.identified?(f.dispatch({type:"INIT",payload:{registryUri:n.registryUri.replace("rho:id:",""),publicKey:e.publicKey}}),i.a.render(r.a.createElement(at,null),document.getElementById("root"))):console.error("This dapp needs identification")})).catch((function(e){console.error("This dapp needs identification"),console.log(e)}))})).catch((function(e){console.error("Something went wrong when retreiving the files module object"),console.log(e)}))}]);